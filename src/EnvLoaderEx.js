// Generated by CoffeeScript 2.5.1
  // EnvLoaderEx.coffee
import {
  strict as assert
} from 'assert';

import {
  dirname,
  resolve,
  parse as parse_fname
} from 'path';

import {
  say,
  undef,
  pass,
  error,
  rtrim,
  isArray,
  isFunction,
  rtrunc
} from '@jdeighan/coffee-utils';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  slurp,
  pathTo,
  mkpath
} from '@jdeighan/coffee-utils/fs';

import {
  PLLParser
} from '@jdeighan/string-input/pll';

// ---------------------------------------------------------------------------
export var EnvLoader = class EnvLoader extends PLLParser {
  constructor(contents, hOptions1 = {}) {
    var key, ref, value;
    super(contents);
    this.hOptions = hOptions1;
    this.prefix = this.hOptions.prefix;
    this.stripPrefix = this.hOptions.stripPrefix;
    this.hCallbacks = this.hOptions.hCallbacks;
    this.checkCallbacks();
    if (this.hOptions.hInitialVars) {
      ref = this.hOptions.hInitialVars;
      for (key in ref) {
        value = ref[key];
        this.setVar(key, value);
      }
    }
  }

  // ..........................................................
  checkCallbacks() {
    var i, lMissing, len, name, ref;
    if (this.hCallbacks != null) {
      lMissing = [];
      ref = ['getVar', 'setVar', 'clearVar', 'clearAll', 'names'];
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        if (!isFunction(this.hCallbacks[name])) {
          lMissing.push(name);
        }
      }
      if (lMissing.length > 0) {
        error(`Missing callbacks: ${lMissing.join(',')}`);
      }
    }
  }

  // ..........................................................
  setVar(name, value) {
    if (this.hCallbacks) {
      this.hCallbacks.setVar(name, value);
    } else {
      process.env[name] = value;
    }
  }

  // ..........................................................
  getVar(name) {
    if (this.hCallbacks) {
      return this.hCallbacks.getVar(name);
    } else {
      return process.env[name];
    }
  }

  // ..........................................................
  clearVar(name) {
    if (this.hCallbacks) {
      this.hCallbacks.clearVar(name);
    } else {
      delete process.env[name];
    }
  }

  // ..........................................................
  clearAll() {
    if (this.hCallbacks) {
      this.hCallbacks.clearAll;
    } else {
      process.env = {};
    }
  }

  // ..........................................................
  names() {
    if (this.hCallbacks) {
      return this.hCallbacks.names();
    } else {
      return Object.keys(process.env);
    }
  }

  // ..........................................................
  dump() {
    var i, len, name, ref;
    say("=== Environment Variables: ===");
    ref = this.names();
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      say(`   ${name} = '${this.getVar(name)}'`);
    }
  }

  // ..........................................................
  mapString(str) {
    var _, key, lMatches, neg, op, value;
    if (lMatches = str.match(/^([A-Za-z_\.]+)\s*=\s*(.*)$/)) { // identifier
      [_, key, value] = lMatches;
      if (this.prefix && (key.indexOf(this.prefix) !== 0)) {
        return undef;
      }
      if (this.stripPrefix) {
        key = key.substring(this.prefix.length);
      }
      return {
        type: 'assign',
        key,
        value: rtrim(value)
      };
    } else if (lMatches = str.match(/^if\s+(?:(not)\s+)?([A-Za-z_]+)$/)) { // identifier
      [_, neg, key] = lMatches;
      if (neg) {
        return {
          type: 'if_falsy',
          key
        };
      } else {
        return {
          type: 'if_truthy',
          key
        };
      }
    } else if (lMatches = str.match(/^if\s+([A-Za-z_][A-Za-z0-9_]*)\s*(is|isnt|>|>=|<|<=)\s*(.*)$/)) { // identifier (key)
      // comparison operator
      [_, key, op, value] = lMatches;
      return {
        type: 'compare',
        key,
        op,
        value: value.trim()
      };
    } else {
      return error(`Invalid line: '${str}'`);
    }
  }

  // ..........................................................
  expand(str) {
    var replacer;
    // --- NOTE: Must use => here, not -> so that "this" is set correctly
    replacer = (str) => {
      return this.getVar(str.substr(1));
    };
    return str.replace(/\$[A-Za-z_][A-Za-z0-9_]*/g, replacer);
  }

  // ..........................................................
  doCompare(arg1, op, arg2) {
    arg1 = this.getVar(arg1);
    arg2 = this.expand(arg2);
    switch (op) {
      case 'is':
        return arg1 === arg2;
      case 'isnt':
        return arg1 !== arg2;
      case '<':
        return Number(arg1) < Number(arg2);
      case '<=':
        return Number(arg1) <= Number(arg2);
      case '>':
        return Number(arg1) > Number(arg2);
      case '>=':
        return Number(arg1) >= Number(arg2);
      default:
        return error(`doCompare(): Invalid operator '${op}'`);
    }
  }

  // ..........................................................
  procEnv(tree) {
    var h, i, key, len, op, value;
    debug("enter procEnv()");
    debug(tree, "TREE:");
    for (i = 0, len = tree.length; i < len; i++) {
      h = tree[i];
      switch (h.node.type) {
        case 'assign':
          ({key, value} = h.node);
          value = this.expand(value);
          this.setVar(key, value);
          debug(`procEnv(): assign ${key} = '${value}'`);
          break;
        case 'if_truthy':
          ({key} = h.node);
          debug(`if_truthy: '${key}'`);
          if (this.getVar(key)) {
            debug(`procEnv(): if_truthy('${key}') - proc body`);
            this.procEnv(h.body);
          } else {
            debug(`procEnv(): if_truthy('${key}') - skip`);
          }
          break;
        case 'if_falsy':
          ({key} = h.node);
          debug(`if_falsy: '${key}'`);
          if (this.getVar(key)) {
            debug(`procEnv(): if_falsy('${key}') - skip`);
          } else {
            debug(`procEnv(): if_falsy('${key}') - proc body`);
            this.procEnv(h.body);
          }
          break;
        case 'compare':
          ({key, op, value} = h.node);
          debug(`procEnv(key=${key}, value=${value})`);
          if (this.doCompare(key, op, value)) {
            debug(`procEnv(): compare('${key}','${value}') - proc body`);
            this.procEnv(h.body);
          } else {
            debug(`procEnv(): compare('${key}','${value}') - skip`);
          }
      }
    }
    debug("return from procEnv()");
  }

  // ..........................................................
  load() {
    var tree;
    debug("enter load()");
    tree = this.getTree();
    assert(tree != null, "load(): tree is undef");
    assert(isArray(tree), "load(): tree is not an array");
    this.procEnv(tree);
    debug("return from load()");
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvFile = function(filepath, hOptions = {}) {
  debug(`LOAD ${filepath}`);
  return loadEnvString(slurp(filepath), hOptions);
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvString = function(contents, hOptions = {}) {
  var env;
  debug("enter loadEnvString()");
  env = new EnvLoader(contents, hOptions);
  env.load();
  debug("return from loadEnvString()");
  return env;
};

// ---------------------------------------------------------------------------
// Load environment from .env file
export var loadEnvFrom = function(searchDir, hOptions = {}) {
  var env, hInitialVars, i, lPaths, len, path, recurse, rootName;
  // --- Valid options:
  //     hInitialVars - set these env vars first
  //     recurse - load all .env files found by searching up
  //     rootName - env var name of first .env file found
  //     any option accepted by EnvLoader
  //        hInitialVars - hash of initial env var values
  //        prefix - load only vars with this prefix
  //        stripPrefix - remove the prefix before setting vars
  //        hCallbacks - callbacks to replace:
  //                     getVar, setVar, clearVar, clearAll, names
  debug(`enter loadEnvFrom('${searchDir}')`);
  ({rootName, hInitialVars, recurse} = hOptions);
  path = pathTo('.env', searchDir, "up");
  if (path == null) {
    return undef;
  }
  if (rootName) {
    if (!hInitialVars) {
      hInitialVars = hOptions.hInitialVars = {};
    }
    hInitialVars[rootName] = mkpath(rtrunc(path, 5));
  }
  if (recurse) {
    lPaths = [path];
    while (path = pathTo('.env', resolve(rtrunc(path, 5), '..'), "up")) {
      lPaths.unshift(path);
    }
    for (i = 0, len = lPaths.length; i < len; i++) {
      path = lPaths[i];
      env = loadEnvFile(path, hOptions);
    }
  } else {
    env = loadEnvFile(path, hOptions);
  }
  debug("return from loadEnvFrom()");
  return env;
};
