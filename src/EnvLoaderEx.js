// Generated by CoffeeScript 2.5.1
  // EnvLoaderEx.coffee
import {
  strict as assert
} from 'assert';

import {
  say,
  undef,
  pass,
  error,
  rtrim,
  isArray,
  isFunction
} from '@jdeighan/coffee-utils';

import {
  debug,
  setDebugging
} from '@jdeighan/coffee-utils/debug';

import {
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  PLLParser
} from '@jdeighan/string-input/pll';

// ---------------------------------------------------------------------------
export var EnvLoader = class EnvLoader extends PLLParser {
  constructor(contents, hOptions1 = {}) {
    var key, ref, value;
    super(contents);
    this.hOptions = hOptions1;
    this.prefix = this.hOptions.prefix;
    this.stripPrefix = this.hOptions.stripPrefix;
    this.hCallbacks = this.hOptions.hCallbacks;
    this.checkCallbacks();
    if (this.hOptions.hInitialVars) {
      ref = this.hOptions.hInitialVars;
      for (key in ref) {
        value = ref[key];
        this.setVar(key, value);
      }
    }
  }

  // ..........................................................
  checkCallbacks() {
    if (this.hCallbacks != null) {
      assert(isFunction(this.hCallbacks.getVar), "checkCallbacks: no getVar");
      assert(isFunction(this.hCallbacks.setVar), "checkCallbacks: no setVar");
      assert(isFunction(this.hCallbacks.clearVar), "checkCallbacks: no clearVar");
      assert(isFunction(this.hCallbacks.names), "checkCallbacks: no names");
    }
  }

  // ..........................................................
  setVar(name, value) {
    if (this.hCallbacks) {
      this.hCallbacks.setVar(name, value);
    } else {
      process.env[name] = value;
    }
  }

  // ..........................................................
  getVar(name) {
    if (this.hCallbacks) {
      return this.hCallbacks.getVar(name);
    } else {
      return process.env[name];
    }
  }

  // ..........................................................
  clearVar(name) {
    if (this.hCallbacks) {
      this.hCallbacks.clearVar(name);
    } else {
      delete process.env[name];
    }
  }

  // ..........................................................
  names() {
    if (this.hCallbacks) {
      return this.hCallbacks.names();
    } else {
      return Object.keys(process.env);
    }
  }

  // ..........................................................
  dump() {
    var i, len, name, ref;
    say("=== Environment Variables: ===");
    ref = this.names();
    for (i = 0, len = ref.length; i < len; i++) {
      name = ref[i];
      say(`   ${name} = '${this.getVar(name)}'`);
    }
  }

  // ..........................................................
  mapString(str) {
    var _, dqstr, ident, key, lMatches, neg, number, op, sqstr, value;
    if (lMatches = str.match(/^([A-Za-z_\.]+)\s*=\s*(.*)$/)) { // identifier
      [_, key, value] = lMatches;
      if (this.prefix && (key.indexOf(this.prefix) !== 0)) {
        return undef;
      }
      if (this.stripPrefix) {
        key = key.substring(this.prefix.length);
      }
      return {
        type: 'assign',
        key,
        value: rtrim(value)
      };
    } else if (lMatches = str.match(/^if\s+(?:(not)\s+)?([A-Za-z_]+)$/)) { // identifier
      [_, neg, key] = lMatches;
      if (neg) {
        return {
          type: 'if_falsy',
          key
        };
      } else {
        return {
          type: 'if_truthy',
          key
        };
      }
    } else if (lMatches = str.match(/^if\s+([A-Za-z_]+)\s*(==|!=|>|>=|<|<=)\s*(?:([A-Za-z_]+)|([0-9]+)|'([^']*)'|"([^"]*)")$/)) { // identifier (key)
      // comparison operator
      // identifier
      // number
      // single quoted string
      // double quoted string
      [_, key, op, ident, number, sqstr, dqstr] = lMatches;
      if (ident) {
        return {
          type: 'compare_ident',
          key,
          op,
          ident
        };
      } else if (number) {
        return {
          type: 'compare_number',
          key,
          op,
          number: Number(number)
        };
      } else if (sqstr) {
        return {
          type: 'compare_string',
          key,
          op,
          string: sqstr
        };
      } else if (dqstr) {
        return {
          type: 'compare_string',
          key,
          op,
          string: dqstr
        };
      } else {
        return error(`Invalid line: '${str}'`);
      }
    } else {
      return error(`Invalid line: '${str}'`);
    }
  }

  // ..........................................................
  doCompare(arg1, op, arg2) {
    switch (op) {
      case '==':
        return arg1 === arg2;
      case '!=':
        return arg1 !== arg2;
      case '<':
        return arg1 < arg2;
      case '<=':
        return arg1 <= arg2;
      case '>':
        return arg1 > arg2;
      case '>=':
        return arg1 >= arg2;
      default:
        return error(`doCompare(): Invalid operator '${op}'`);
    }
  }

  // ..........................................................
  load() {
    var tree;
    debug("enter load()");
    tree = this.getTree();
    assert(tree != null, "load(): tree is undef");
    assert(isArray(tree), "load(): tree is not an array");
    this.procEnv(tree);
    debug("return from load()");
  }

  procEnv(tree) {
    var arg1, arg2, h, i, ident, key, len, number, op, replacer, string, value;
    debug("enter procEnv()");
    debug(tree, "TREE:");
    // --- NOTE: Must use => here, not ->
    //           so that "this" is set correctly
    replacer = (str) => {
      var name, result;
      debug(`enter replacer('${str}')`);
      name = str.substr(1);
      debug(`name = '${name}'`);
      result = this.getVar(name);
      debug(`return with '${result}'`);
      return result;
    };
    for (i = 0, len = tree.length; i < len; i++) {
      h = tree[i];
      switch (h.node.type) {
        case 'assign':
          ({key, value} = h.node);
          value = value.replace(/\$[A-Za-z_]+/g, replacer);
          this.setVar(key, value);
          debug(`procEnv(): assign ${key} = '${value}'`);
          break;
        case 'if_truthy':
          ({key} = h.node);
          debug(`if_truthy: '${key}'`);
          if (this.getVar(key)) {
            debug("YES: proc body");
            this.procEnv(h.body);
          }
          break;
        case 'if_falsy':
          ({key} = h.node);
          debug(`if_falsy: '${key}'`);
          if (!this.getVar(key)) {
            debug("YES: proc body");
            this.procEnv(h.body);
          }
          break;
        case 'compare_ident':
          ({key, op, ident} = h.node);
          arg1 = this.getVar(key);
          arg2 = this.getVar(ident);
          if (this.doCompare(arg1, op, arg2)) {
            this.procEnv(h.body);
          }
          break;
        case 'compare_number':
          ({key, op, number} = h.node);
          arg1 = Number(this.getVar(key));
          if (this.doCompare(arg1, op, number)) {
            this.procEnv(h.body);
          }
          break;
        case 'compare_string':
          ({key, op, string} = h.node);
          arg1 = this.getVar(key);
          if (this.doCompare(arg1, op, string)) {
            this.procEnv(h.body);
          }
      }
    }
    debug("return from procEnv()");
  }

};

// ---------------------------------------------------------------------------
// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvFile = function(filepath, hOptions = {}) {
  var env;
  debug(`enter loadEnvFile('${filepath}')`);
  env = loadEnvString(slurp(filepath), hOptions);
  debug("return from loadEnvFile()");
  return env;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvString = function(contents, hOptions = {}) {
  var env;
  debug("enter loadEnvString()");
  env = new EnvLoader(contents, hOptions);
  env.load();
  debug("return from loadEnvString()");
  return env;
};

// ---------------------------------------------------------------------------
// Load environment from .env file
export var loadEnvFrom = function(searchDir, hOptions = {}) {
  var env, filepath;
  // --- Valid options:
  //     recurse - load all .env files found by searching up
  //     rootName - env var name of first .env file found
  //     any option accepted by EndLoader
  debug("enter loadEnvFrom()");
  filepath = pathTo('.env', searchDir, "up");
  assert(filepath != null, "No .env file found");
  if (hOptions.rootName) {
    if (!hOptions.hInitialVars) {
      hOptions.hInitialVars = {};
    }
    hOptions.hInitialVars[hOptions.rootName] = filepath;
  }
  env = loadEnvFile(filepath, hOptions);
  if (!hOptions.recurse) {
    debug("return from loadEnvFrom()");
    return env;
  }
  while (filepath = pathTo('.env', filepath.substring(0, filepath.length - 5), "up")) {
    debug(`Also load ${filepath}`);
    env = loadEnvFile(filepath, prefix);
  }
  debug("return from loadEnvFrom()");
  return env;
};
