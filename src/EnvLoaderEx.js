// Generated by CoffeeScript 2.5.1
// EnvLoaderEx.coffee
var doCompare, getdir, replacer;

import {
  strict as assert
} from 'assert';

import {
  say,
  undef,
  pass,
  error,
  rtrim,
  isArray
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  PLLParser
} from '@jdeighan/string-input/pll';

// ---------------------------------------------------------------------------
export var setenv = function(name, value) {
  debug(`SET ENV '${name}' = '${value}'`);
  process.env[name] = value;
};

// ---------------------------------------------------------------------------
export var getenv = function(name) {
  debug(`GET ENV '${name}'`);
  return process.env[name];
};

// ---------------------------------------------------------------------------
export var clearenv = function(...lNames) {
  var i, len1, name;
  debug(`CLEAR ENV ${lNames.join(', ')}`);
  for (i = 0, len1 = lNames.length; i < len1; i++) {
    name = lNames[i];
    delete process.env[name];
  }
};

// ---------------------------------------------------------------------------
export var EnvInput = class EnvInput extends PLLParser {
  constructor(string, prefix1) {
    super(string);
    this.prefix = prefix1;
  }

  mapString(str) {
    var _, dqstr, ident, key, lMatches, neg, number, op, sqstr, value;
    if (lMatches = str.match(/^([A-Za-z_\.]+)\s*=\s*(.*)$/)) { // identifier
      [_, key, value] = lMatches;
      if (this.prefix && (key.indexOf(this.prefix) !== 0)) {
        return undef;
      }
      value = rtrim(value);
      return {
        type: 'assign',
        key,
        value
      };
    } else if (lMatches = str.match(/^if\s+(?:(not)\s+)?([A-Za-z_]+)$/)) { // identifier
      [_, neg, key] = lMatches;
      if (neg) {
        return {
          type: 'if_falsy',
          key
        };
      } else {
        return {
          type: 'if_truthy',
          key
        };
      }
    } else if (lMatches = str.match(/^if\s+([A-Za-z_]+)\s*(==|!=|>|>=|<|<=)\s*(?:([A-Za-z_]+)|([0-9]+)|'([^']*)'|"([^"]*)")$/)) { // identifier (key)
      // comparison operator
      // identifier
      // number
      // single quoted string
      // double quoted string
      [_, key, op, ident, number, sqstr, dqstr] = lMatches;
      if (ident) {
        return {
          type: 'compare_ident',
          key,
          op,
          ident
        };
      } else if (number) {
        return {
          type: 'compare_number',
          key,
          op,
          number: Number(number)
        };
      } else if (sqstr) {
        return {
          type: 'compare_string',
          key,
          op,
          string: sqstr
        };
      } else if (dqstr) {
        return {
          type: 'compare_string',
          key,
          op,
          string: dqstr
        };
      } else {
        return error(`Invalid line: '${str}'`);
      }
    } else {
      return error(`Invalid line: '${str}'`);
    }
  }

};

// ---------------------------------------------------------------------------
getdir = function(fullpath) {
  var len;
  // --- Works only if file name is '.env'
  len = fullpath.length;
  return fullpath.substring(0, len - 5);
};

// ---------------------------------------------------------------------------
// Load environment from .env file
export var loadEnvFrom = function(searchDir, hOptions = {}) {
  var filepath, prefix, recurse;
  // --- Valid options:
  //     recurse - load all .env files found by searching up
  //     prefix - load only env vars with the given prefix
  debug("enter loadEnvFrom()");
  ({recurse, prefix} = hOptions);
  filepath = pathTo('.env', searchDir, "up");
  if (filepath == null) {
    debug("return - no .env file found");
    return;
  }
  loadEnvFile(filepath, prefix);
  if (!recurse) {
    debug("return from loadEnvFrom()");
    return;
  }
  while (filepath = pathTo('.env', getdir(filepath), "up")) {
    loadEnvFile(filepath, prefix);
  }
  debug("return from loadEnvFrom()");
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvFile = function(filepath, prefix = undef) {
  debug(`enter loadEnvFile('${filepath}')`);
  loadEnvString(slurp(filepath), prefix);
  debug("return from loadEnvFile()");
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvString = function(contents, prefix = undef) {
  var oInput, tree;
  debug("enter loadEnvString()");
  oInput = new EnvInput(contents, prefix);
  tree = oInput.getTree();
  procEnv(tree);
  debug("return from loadEnvString()");
};

// ---------------------------------------------------------------------------
doCompare = function(arg1, op, arg2) {
  switch (op) {
    case '==':
      return arg1 === arg2;
    case '!=':
      return arg1 !== arg2;
    case '<':
      return arg1 < arg2;
    case '<=':
      return arg1 <= arg2;
    case '>':
      return arg1 > arg2;
    case '>=':
      return arg1 >= arg2;
    default:
      return error(`doCompare(): Invalid operator '${op}'`);
  }
};

// ---------------------------------------------------------------------------
replacer = function(str) {
  var name, result;
  debug(`enter replacer('${str}')`);
  name = str.substr(1);
  debug(`name = '${name}'`);
  result = getenv(name);
  debug(`return with '${result}'`);
  return result;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var procEnv = function(tree) {
  var arg1, arg2, h, i, ident, key, len1, number, op, string, value;
  debug("enter procEnv() - tree");
  assert(isArray(tree), "procEnv(): tree is not an array");
  for (i = 0, len1 = tree.length; i < len1; i++) {
    h = tree[i];
    switch (h.node.type) {
      case 'assign':
        ({key, value} = h.node);
        value = value.replace(/\$[A-Za-z_]+/g, replacer);
        setenv(key, value);
        debug(`procEnv(): assign ${key} = '${value}'`);
        break;
      case 'if_truthy':
        ({key} = h.node);
        debug(`if_truthy: '${key}'`);
        if (getenv(key)) {
          debug("YES: proc body");
          procEnv(h.body);
        }
        break;
      case 'if_falsy':
        ({key} = h.node);
        debug(`if_falsy: '${key}'`);
        if (!getenv(key)) {
          debug("YES: proc body");
          procEnv(h.body);
        }
        break;
      case 'compare_ident':
        ({key, op, ident} = h.node);
        arg1 = getenv(key);
        arg2 = getenv(ident);
        if (doCompare(arg1, op, arg2)) {
          procEnv(h.body);
        }
        break;
      case 'compare_number':
        ({key, op, number} = h.node);
        arg1 = Number(getenv(key));
        if (doCompare(arg1, op, number)) {
          procEnv(h.body);
        }
        break;
      case 'compare_string':
        ({key, op, string} = h.node);
        arg1 = getenv(key);
        if (doCompare(arg1, op, string)) {
          procEnv(h.body);
        }
    }
  }
  debug("return from procEnv()");
};

// ---------------------------------------------------------------------------
