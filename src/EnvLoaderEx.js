// Generated by CoffeeScript 2.5.1
// EnvLoaderEx.coffee
var doCompare, getenv, replacer, setenv;

import assert from 'assert';

import {
  say,
  undef,
  pass,
  error,
  warn,
  rtrim,
  isArray
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  PLLParser
} from '@jdeighan/string-input/pll';

// ---------------------------------------------------------------------------
setenv = function(name, value) {
  debug(`SET ENV '${name}' = '${value}'`);
  process.env[name] = value;
};

// ---------------------------------------------------------------------------
getenv = function(name) {
  return process.env[name];
};

// ---------------------------------------------------------------------------
export var EnvInput = class EnvInput extends PLLParser {
  mapString(str) {
    var _, dqstr, ident, key, lMatches, neg, number, op, sqstr, value;
    if (lMatches = str.match(/^([A-Za-z_]+)\s*=\s*(.*)$/)) { // identifier
      [_, key, value] = lMatches;
      value = rtrim(value);
      return {
        type: 'assign',
        key,
        value
      };
    } else if (lMatches = str.match(/^if\s+(?:(not)\s+)?([A-Za-z_]+)$/)) { // identifier
      [_, neg, key] = lMatches;
      if (neg) {
        return {
          type: 'if_falsy',
          key
        };
      } else {
        return {
          type: 'if_truthy',
          key
        };
      }
    } else if (lMatches = str.match(/^if\s+([A-Za-z_]+)\s*(==|!=|>|>=|<|<=)\s*(?:([A-Za-z_]+)|([0-9]+)|'([^']*)'|"([^"]*)")$/)) { // identifier (key)
      // comparison operator
      // identifier
      // number
      // single quoted string
      // double quoted string
      [_, key, op, ident, number, sqstr, dqstr] = lMatches;
      if (ident) {
        return {
          type: 'compare_ident',
          key,
          op,
          ident
        };
      } else if (number) {
        return {
          type: 'compare_number',
          key,
          op,
          number: Number(number)
        };
      } else if (sqstr) {
        return {
          type: 'compare_string',
          key,
          op,
          string: sqstr
        };
      } else if (dqstr) {
        return {
          type: 'compare_string',
          key,
          op,
          string: dqstr
        };
      } else {
        return error(`Invalid line: '${str}'`);
      }
    } else {
      return error(`Invalid line: '${str}'`);
    }
  }

};

// ---------------------------------------------------------------------------
// Load environment from .env file
export var loadEnvFrom = function(searchDir, rootName = undef) {
  var tree;
  debug("enter loadEnvFrom()");
  tree = loadEnvFile(searchDir, rootName);
  procEnv(tree);
  debug("return from loadEnvFrom()");
  return tree;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvFile = function(searchDir, rootName = undef) {
  var contents, filepath, tree;
  debug(`enter loadEnvFile('${searchDir}')`);
  filepath = pathTo('.env', searchDir, "up");
  if (filepath == null) {
    warn(`loadEnvFile('${searchDir}'): No .env file found`);
    debug("return - no .env file found");
    return;
  }
  if (rootName) {
    setenv(rootName, filepath);
  }
  contents = slurp(filepath);
  tree = parseEnv(contents);
  debug("return from loadEnvFile() - tree");
  return tree;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var parseEnv = function(contents) {
  var oInput, tree;
  debug("enter ENV parseEnv()");
  oInput = new EnvInput(contents);
  tree = oInput.getTree();
  debug("return ENV from parseEnv() - tree");
  return tree;
};

// ---------------------------------------------------------------------------
doCompare = function(arg1, op, arg2) {
  switch (op) {
    case '==':
      return arg1 === arg2;
    case '!=':
      return arg1 !== arg2;
    case '<':
      return arg1 < arg2;
    case '<=':
      return arg1 <= arg2;
    case '>':
      return arg1 > arg2;
    case '>=':
      return arg1 >= arg2;
    default:
      return error(`doCompare(): Invalid operator '${op}'`);
  }
};

// ---------------------------------------------------------------------------
replacer = function(str) {
  var name, result;
  debug(`enter ENV replacer('${str}')`);
  name = str.substr(1);
  debug(`ENV name = '${name}'`);
  result = getenv(name);
  debug(`return ENV with '${result}'`);
  return result;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var procEnv = function(tree) {
  var arg1, arg2, h, i, ident, key, len, number, op, string, value;
  debug("enter ENV procEnv() - tree");
  assert(isArray(tree), "procEnv(): tree is not an array");
  for (i = 0, len = tree.length; i < len; i++) {
    h = tree[i];
    switch (h.node.type) {
      case 'assign':
        ({key, value} = h.node);
        value = value.replace(/\$[A-Za-z_]+/g, replacer);
        setenv(key, value);
        debug(`ENV procEnv(): assign ${key} = '${value}'`);
        break;
      case 'if_truthy':
        ({key} = h.node);
        debug(`if_truthy: '${key}'`);
        if (getenv(key)) {
          debug("YES: proc body");
          procEnv(h.body);
        }
        break;
      case 'if_falsy':
        ({key} = h.node);
        debug(`if_falsy: '${key}'`);
        if (!getenv(key)) {
          debug("YES: proc body");
          procEnv(h.body);
        }
        break;
      case 'compare_ident':
        ({key, op, ident} = h.node);
        arg1 = getenv(key);
        arg2 = getenv(ident);
        if (doCompare(arg1, op, arg2)) {
          procEnv(h.body);
        }
        break;
      case 'compare_number':
        ({key, op, number} = h.node);
        arg1 = Number(getenv(key));
        if (doCompare(arg1, op, number)) {
          procEnv(h.body);
        }
        break;
      case 'compare_string':
        ({key, op, string} = h.node);
        arg1 = getenv(key);
        if (doCompare(arg1, op, string)) {
          procEnv(h.body);
        }
    }
  }
  debug("return ENV from procEnv()");
};

// ---------------------------------------------------------------------------
