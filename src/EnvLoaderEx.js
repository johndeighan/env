// Generated by CoffeeScript 2.5.1
// EnvLoaderEx.coffee
var doCompare;

import assert from 'assert';

import {
  say,
  undef,
  pass,
  error,
  warn,
  rtrim,
  isArray
} from '@jdeighan/coffee-utils';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  slurp,
  pathTo
} from '@jdeighan/coffee-utils/fs';

import {
  parsePLL
} from '@jdeighan/string-input/pll';

// ---------------------------------------------------------------------------
// Load environment from .env file
export var loadEnvFrom = function(searchDir) {
  var tree;
  debug("enter loadEnvFrom()");
  tree = loadEnvFile(searchDir);
  procEnv(tree);
  debug("return from loadEnvFrom()");
  return tree;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var loadEnvFile = function(searchDir) {
  var contents, filepath, tree;
  debug(`enter loadEnvFile('${searchDir}')`);
  filepath = pathTo('.env', searchDir, "up");
  if (filepath == null) {
    warn(`loadEnvFile('${searchDir}'): No .env file found`);
    debug("return - no .env file found");
    return;
  }
  contents = slurp(filepath);
  tree = parseEnv(contents);
  debug("return from loadEnvFile() - tree");
  return tree;
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var parseEnv = function(contents) {
  var tree;
  debug("enter parseEnv()");
  tree = parsePLL(contents, EnvMapper);
  debug("return from parseEnv() - tree");
  return tree;
};

// ---------------------------------------------------------------------------
doCompare = function(arg1, op, arg2) {
  switch (op) {
    case '==':
      return arg1 === arg2;
    case '!=':
      return arg1 !== arg2;
    case '<':
      return arg1 < arg2;
    case '<=':
      return arg1 <= arg2;
    case '>':
      return arg1 > arg2;
    case '>=':
      return arg1 >= arg2;
    default:
      return error(`doCompare(): Invalid operator '${op}'`);
  }
};

// ---------------------------------------------------------------------------
// Load environment from a string
export var procEnv = function(tree) {
  var arg1, arg2, h, i, ident, key, len, number, op, string, value;
  debug("enter procEnv() - tree");
  assert(isArray(tree), "procEnv(): tree is not an array");
  for (i = 0, len = tree.length; i < len; i++) {
    h = tree[i];
    switch (h.node.type) {
      case 'assign':
        ({key, value} = h.node);
        process.env[key] = value;
        debug(`assign ${key} = '${value}'`);
        break;
      case 'if_truthy':
        ({key} = h.node);
        debug(`if_truthy: '${key}'`);
        if (process.env[key]) {
          debug("YES: proc body");
          procEnv(h.body);
        }
        break;
      case 'if_falsy':
        ({key} = h.node);
        debug(`if_falsy: '${key}'`);
        if (!process.env[key]) {
          debug("YES: proc body");
          procEnv(h.body);
        }
        break;
      case 'compare_ident':
        ({key, op, ident} = h.node);
        arg1 = process.env[key];
        arg2 = process.env[ident];
        if (doCompare(arg1, op, arg2)) {
          procEnv(h.body);
        }
        break;
      case 'compare_number':
        ({key, op, number} = h.node);
        arg1 = Number(process.env[key]);
        if (doCompare(arg1, op, number)) {
          procEnv(h.body);
        }
        break;
      case 'compare_string':
        ({key, op, string} = h.node);
        arg1 = process.env[key];
        if (doCompare(arg1, op, string)) {
          procEnv(h.body);
        }
    }
  }
  debug("return from procEnv()");
};

// ---------------------------------------------------------------------------
export var EnvMapper = function(str) {
  var _, dqstr, ident, key, lMatches, neg, number, op, sqstr, value;
  if (lMatches = str.match(/^([A-Za-z_]+)\s*=\s*(.*)$/)) { // identifier
    [_, key, value] = lMatches;
    key = key.toUpperCase();
    value = rtrim(value);
    return {
      type: 'assign',
      key,
      value
    };
  } else if (lMatches = str.match(/^if\s+(?:(not)\s+)?([A-Za-z_]+)$/)) { // identifier
    [_, neg, key] = lMatches;
    key = key.toUpperCase();
    if (neg) {
      return {
        type: 'if_falsy',
        key
      };
    } else {
      return {
        type: 'if_truthy',
        key
      };
    }
  } else if (lMatches = str.match(/^if\s+([A-Za-z_]+)\s*(==|!=|>|>=|<|<=)\s*(?:([A-Za-z_]+)|([0-9]+)|'([^']*)'|"([^"]*)")$/)) { // identifier (key)
    // comparison operator
    // identifier
    // number
    // single quoted string
    // double quoted string
    [_, key, op, ident, number, sqstr, dqstr] = lMatches;
    key = key.toUpperCase();
    if (ident) {
      return {
        type: 'compare_ident',
        key,
        op,
        ident
      };
    } else if (number) {
      return {
        type: 'compare_number',
        key,
        op,
        number: Number(number)
      };
    } else if (sqstr) {
      return {
        type: 'compare_string',
        key,
        op,
        string: sqstr
      };
    } else if (dqstr) {
      return {
        type: 'compare_string',
        key,
        op,
        string: dqstr
      };
    } else {
      return error(`Invalid line: '${str}'`);
    }
  } else {
    return error(`Invalid line: '${str}'`);
  }
};

// ---------------------------------------------------------------------------
